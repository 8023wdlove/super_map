import{a as He}from"./chunk-XJVZABJP.js";import{a as me,b as ye}from"./chunk-APJGGXML.js";import{a as j}from"./chunk-ELQX5BPQ.js";import{a as Ve}from"./chunk-ZJ45HMNY.js";import{a as Z}from"./chunk-SP6GVFX5.js";import{b as ae}from"./chunk-LKTE2YWL.js";import{a as Ae,b as ne}from"./chunk-RELHBJJP.js";import"./chunk-W3WRSDQH.js";import"./chunk-VETUMSV6.js";import{a as le}from"./chunk-PWT2ZHRH.js";import{a as Ie}from"./chunk-ATOK5GBF.js";import"./chunk-MJVT7BN7.js";import"./chunk-WTYKDBBN.js";import{a as Fe,b as De}from"./chunk-OGTTQ4KL.js";import"./chunk-7AR5UXG3.js";import{a as q}from"./chunk-W2I2FV32.js";import{a as Ee}from"./chunk-XKBSMKNP.js";import"./chunk-J4ID4JKR.js";import{d as Se,h as we,n as Ne,o as ee}from"./chunk-K2IDXOCV.js";import"./chunk-NPAFDOYL.js";import{a as W}from"./chunk-45OWWDV7.js";import{a as x}from"./chunk-JX5O4HI2.js";import"./chunk-6S43R6PL.js";import"./chunk-TW5GUTQO.js";import"./chunk-ZRLECQ27.js";import{a as F}from"./chunk-FEOWMVRK.js";import{a as S,b as de}from"./chunk-CUQT2UK5.js";import"./chunk-CB3KB2D3.js";import{a as h,c as $}from"./chunk-I46SWINN.js";import{a as m}from"./chunk-LNIYJJXS.js";import{a as E}from"./chunk-4D2ERGZX.js";import{a as V}from"./chunk-EDZQSM3T.js";import{a as Pe}from"./chunk-PJGSCWXZ.js";import{a as C}from"./chunk-NUC3LT2W.js";import"./chunk-SFC4FDPW.js";function O(e,r){this.position=e,C(this.position)||(this.position=new F),this.tangentPlane=r,C(this.tangentPlane)||(this.tangentPlane=O.NORTH_POLE_TANGENT_PLANE)}Object.defineProperties(O.prototype,{ellipsoid:{get:function(){return this.tangentPlane.ellipsoid}},x:{get:function(){return this.position.x}},y:{get:function(){return this.position.y}},conformalLatitude:{get:function(){let e=F.magnitude(this.position),r=2*this.ellipsoid.maximumRadius;return this.tangentPlane.plane.normal.z*(m.PI_OVER_TWO-2*Math.atan2(e,r))}},longitude:{get:function(){let e=m.PI_OVER_TWO+Math.atan2(this.y,this.x);return e>Math.PI&&(e-=m.TWO_PI),e}}});var ce=new $,qe=new h;O.prototype.getLatitude=function(e){C(e)||(e=S.WGS84),ce.latitude=this.conformalLatitude,ce.longitude=this.longitude,ce.height=0;let r=this.ellipsoid.cartographicToCartesian(ce,qe);return e.cartesianToCartographic(r,ce),ce.latitude};var Qe=new Fe,Ze=new h,Ke=new h;O.fromCartesian=function(e,r){V.defined("cartesian",e);let t=m.signNotZero(e.z),i=O.NORTH_POLE_TANGENT_PLANE,a=O.SOUTH_POLE;t<0&&(i=O.SOUTH_POLE_TANGENT_PLANE,a=O.NORTH_POLE);let o=Qe;o.origin=i.ellipsoid.scaleToGeocentricSurface(e,o.origin),o.direction=h.subtract(o.origin,a,Ze),h.normalize(o.direction,o.direction);let n=De.rayPlane(o,i.plane,Ke),c=h.subtract(n,a,n),s=h.dot(i.xAxis,c),l=t*h.dot(i.yAxis,c);return C(r)?(r.position=new F(s,l),r.tangentPlane=i,r):new O(new F(s,l),i)};O.fromCartesianArray=function(e,r){V.defined("cartesians",e);let t=e.length;C(r)?r.length=t:r=new Array(t);for(let i=0;i<t;i++)r[i]=O.fromCartesian(e[i],r[i]);return r};O.clone=function(e,r){if(!!C(e))return C(r)?(r.position=e.position,r.tangentPlane=e.tangentPlane,r):new O(e.position,e.tangentPlane)};O.HALF_UNIT_SPHERE=Object.freeze(new S(.5,.5,.5));O.NORTH_POLE=Object.freeze(new h(0,0,.5));O.SOUTH_POLE=Object.freeze(new h(0,0,-.5));O.NORTH_POLE_TANGENT_PLANE=Object.freeze(new ae(O.NORTH_POLE,O.HALF_UNIT_SPHERE));O.SOUTH_POLE_TANGENT_PLANE=Object.freeze(new ae(O.SOUTH_POLE,O.HALF_UNIT_SPHERE));var K=O;var Je=new $,Me=new $;function Xe(e,r,t,i){var a=i.cartesianToCartographic(e,Je),o=a.height,n=i.cartesianToCartographic(r,Me);n.height=o,i.cartographicToCartesian(n,r);var c=i.cartesianToCartographic(t,Me);c.height=o-100,i.cartographicToCartesian(c,t)}var $e=new Ve,xe=new h,er=new h,rr=new h,tr=new h,ir=new h,ar=new h,Oe=new h,Q=new h,he=new h,or=new F,nr=new F,cr=new h,We=new we,hr=new W,sr=new W;function Ce(e){var r=e.vertexFormat,t=e.geometry,i=e.shadowVolume,a=t.attributes.position.values,o=a.length,n=e.wall,c=e.top,s=e.bottom;if(r.st||r.normal||r.tangent||r.bitangent||i){var l=e.boundingRectangle,g=e.tangentPlane,T=e.ellipsoid,v=e.stRotation,P=e.perPositionHeight,D=or;D.x=l.x,D.y=l.y;var L=e.isComputeTexCoord?new Float32Array(o):new Float32Array(2*(o/3)),p=r.st?L:void 0,u;r.normal&&(P&&c&&!n?u=t.attributes.normal.values:u=new Float32Array(o));var N=r.tangent?new Float32Array(o):void 0,b=r.bitangent?new Float32Array(o):void 0,d=i?new Float32Array(o):void 0,w=0,A=0,f=er,y=rr,H=tr,U=!0,R=hr,M=sr;if(v!==0){var k=we.fromAxisAngle(g._plane.normal,v,We);R=W.fromQuaternion(k,R),k=we.fromAxisAngle(g._plane.normal,-v,We),M=W.fromQuaternion(k,M)}else R=W.clone(W.IDENTITY,R),M=W.clone(W.IDENTITY,M);var _=0,I=0;(c&&s||n)&&(_=o/2,I=o/3,o/=2);var J=1,ve=[];if(r.st&&n&&e.isComputeTexCoord){let oe=[...e.outerPositions,e.outerPositions[0]];for(let Te=1;Te<oe.length;Te++){let Ge=h.distance(oe[Te-1],oe[Te]);J+=Ge,ve.push(J)}}for(var te=0;te<o;te+=3){var X=h.fromArray(a,te,cr);if(r.st){var pe=W.multiplyByVector(R,X,xe);pe=T.scaleToGeodeticSurface(pe,pe);var _e=g.projectPointOntoPlane(pe,nr);F.subtract(_e,D,_e);var fe=m.clamp(_e.x/l.width,0,1),be=m.clamp(_e.y/l.height,0,1);if(n&&J>1){let oe=Math.ceil(te/6)-1;fe=ve[oe]?ve[oe]/J:0,p[w]=1-fe,p[w+1]=1,p[w+2]=0,p[w+_]=1-fe,p[w+1+_]=0,p[w+2+_]=0}s&&(p[w+_]=fe,p[w+1+_]=be,e.isComputeTexCoord&&(p[w+2+_]=-1)),c&&(p[w]=fe,p[w+1]=be,e.isComputeTexCoord&&(p[w+2]=1)),e.isComputeTexCoord?w+=3:w+=2}if(r.normal||r.tangent||r.bitangent||i){var Y=A+1,G=A+2;if(n){if(te+3<o){var ue=h.fromArray(a,te+3,ir);if(U){var ge=h.fromArray(a,te+o,ar);P&&Xe(X,ue,ge,T),h.subtract(ue,X,ue),h.subtract(ge,X,ge),f=h.normalize(h.cross(ge,ue,f),f),U=!1}h.equalsEpsilon(ue,X,m.EPSILON10)&&(U=!0)}(r.tangent||r.bitangent)&&(H=T.geodeticSurfaceNormal(X,H),r.tangent&&(y=h.normalize(h.cross(H,f,y),y)))}else f=T.geodeticSurfaceNormal(X,f),(r.tangent||r.bitangent)&&(P&&(Oe=h.fromArray(u,A,Oe),Q=h.cross(h.UNIT_Z,Oe,Q),Q=h.normalize(W.multiplyByVector(M,Q,Q),Q),r.bitangent&&(he=h.normalize(h.cross(Oe,Q,he),he))),y=h.cross(h.UNIT_Z,f,y),y=h.normalize(W.multiplyByVector(M,y,y),y),r.bitangent&&(H=h.normalize(h.cross(f,y,H),H)));r.normal&&(e.wall?(u[A+_]=f.x,u[Y+_]=f.y,u[G+_]=f.z):s&&(u[A+_]=-f.x,u[Y+_]=-f.y,u[G+_]=-f.z),(c&&!P||n)&&(u[A]=f.x,u[Y]=f.y,u[G]=f.z)),i&&(n&&(f=T.geodeticSurfaceNormal(X,f)),d[A+_]=-f.x,d[Y+_]=-f.y,d[G+_]=-f.z),r.tangent&&(e.wall?(N[A+_]=y.x,N[Y+_]=y.y,N[G+_]=y.z):s&&(N[A+_]=-y.x,N[Y+_]=-y.y,N[G+_]=-y.z),c&&(P?(N[A]=Q.x,N[Y]=Q.y,N[G]=Q.z):(N[A]=y.x,N[Y]=y.y,N[G]=y.z))),r.bitangent&&(s&&(b[A+_]=H.x,b[Y+_]=H.y,b[G+_]=H.z),c&&(P?(b[A]=he.x,b[Y]=he.y,b[G]=he.z):(b[A]=H.x,b[Y]=H.y,b[G]=H.z))),A+=3}}r.st&&(t.attributes.st=new ee({componentDatatype:x.FLOAT,componentsPerAttribute:e.isComputeTexCoord?3:2,values:p})),r.normal&&(t.attributes.normal=new ee({componentDatatype:x.FLOAT,componentsPerAttribute:3,values:u})),r.tangent&&(t.attributes.tangent=new ee({componentDatatype:x.FLOAT,componentsPerAttribute:3,values:N})),r.bitangent&&(t.attributes.bitangent=new ee({componentDatatype:x.FLOAT,componentsPerAttribute:3,values:b})),i&&(t.attributes.extrudeDirection=new ee({componentDatatype:x.FLOAT,componentsPerAttribute:3,values:d}))}if(e.extrude&&C(e.offsetAttribute)){var Re=a.length/3,ie=new Uint8Array(Re);if(e.offsetAttribute===ye.TOP)c&&s||n?ie=me(ie,1,0,Re/2):c&&(ie=me(ie,1));else{var Ye=e.offsetAttribute===ye.NONE?0:1;ie=me(ie,Ye)}t.attributes.applyOffset=new ee({componentDatatype:x.UNSIGNED_BYTE,componentsPerAttribute:1,values:ie})}return t}var vr=new $,fr=new $,re={westOverIDL:0,eastOverIDL:0},se=new He;function ke(e,r,t,i,a){if(a=E(a,new de),!C(e)||e.length<3)return a.west=0,a.north=0,a.south=0,a.east=0,a;if(t===Z.RHUMB)return de.fromCartesianArray(e,r,a);se.ellipsoid.equals(r)||(se=new He(void 0,void 0,r)),a.west=Number.POSITIVE_INFINITY,a.east=Number.NEGATIVE_INFINITY,a.south=Number.POSITIVE_INFINITY,a.north=Number.NEGATIVE_INFINITY,re.westOverIDL=Number.POSITIVE_INFINITY,re.eastOverIDL=Number.NEGATIVE_INFINITY;for(var o=1/m.chordLength(i,r.maximumRadius),n=e.length,c=r.cartesianToCartographic(e[0],fr),s=vr,l,g=1;g<n;g++)l=s,s=c,c=r.cartesianToCartographic(e[g],l),se.setEndPoints(s,c),je(se,o,a,re);return l=s,s=c,c=r.cartesianToCartographic(e[0],l),se.setEndPoints(s,c),je(se,o,a,re),a.east-a.west>re.eastOverIDL-re.westOverIDL&&(a.west=re.westOverIDL,a.east=re.eastOverIDL,a.east>m.PI&&(a.east=a.east-m.TWO_PI),a.west>m.PI&&(a.west=a.west-m.TWO_PI)),a}var ur=new $;function je(e,r,t,i){for(var a=e.surfaceDistance,o=Math.ceil(a*r),n=o>0?a/(o-1):Number.POSITIVE_INFINITY,c=0,s=0;s<o;s++){var l=e.interpolateUsingSurfaceDistance(c,ur);c+=n;var g=l.longitude,T=l.latitude;t.west=Math.min(t.west,g),t.east=Math.max(t.east,g),t.south=Math.min(t.south,T),t.north=Math.max(t.north,T);let v=g>=0?g:g+m.TWO_PI;i.westOverIDL=Math.min(i.westOverIDL,v),i.eastOverIDL=Math.max(i.eastOverIDL,v)}}var ze=[];function mr(e,r,t,i,a,o,n,c,s,l,g){var T={walls:[]},v;if(o||n){var P=j.createGeometryFromPositions(e,r,t,a,c,s),D=P.attributes.position.values,L=P.indices,p,u;if(o&&n){var N=D.concat(D);p=N.length/3,u=Ee.createTypedArray(p,L.length*2),u.set(L);var b=L.length,d=p/2;for(v=0;v<b;v+=3){var w=u[v]+d,A=u[v+1]+d,f=u[v+2]+d;u[v+b]=f,u[v+1+b]=A,u[v+2+b]=w}if(P.attributes.position.values=N,a&&c.normal){var y=P.attributes.normal.values;P.attributes.normal.values=new Float32Array(N.length),P.attributes.normal.values.set(y)}P.indices=u}else if(n){for(p=D.length/3,u=Ee.createTypedArray(p,L.length),v=0;v<L.length;v+=3)u[v]=L[v+2],u[v+1]=L[v+1],u[v+2]=L[v];P.indices=u}T.topAndBottom=new le({geometry:P})}var H=i.outerRing,U=ae.fromPoints(H,e),R=U.projectPointsOntoPlane(H,ze),M=ne.computeWindingOrder2D(R);M===Ae.CLOCKWISE&&(H=H.slice().reverse());var k;l&&(k=j.computeWallGeometry(H,e,t,a,s,g),T.walls.push(new le({geometry:k})));var _=i.holes;for(v=0;v<_.length;v++){var I=_[v];U=ae.fromPoints(I,e),R=U.projectPointsOntoPlane(I,ze),M=ne.computeWindingOrder2D(R),M===Ae.COUNTER_CLOCKWISE&&(I=I.slice().reverse()),k=j.computeWallGeometry(I,e,t,a,s),T.walls.push(new le({geometry:k}))}return T}function B(e){if(V.typeOf.object("options",e),V.typeOf.object("options.polygonHierarchy",e.polygonHierarchy),C(e.perPositionHeight)&&e.perPositionHeight&&C(e.height))throw new Pe("Cannot use both options.perPositionHeight and options.height");if(C(e.arcType)&&e.arcType!==Z.GEODESIC&&e.arcType!==Z.RHUMB)throw new Pe("Invalid arcType. Valid options are ArcType.GEODESIC and ArcType.RHUMB.");var r=e.polygonHierarchy,t=E(e.vertexFormat,q.DEFAULT),i=E(e.ellipsoid,S.WGS84),a=E(e.granularity,m.RADIANS_PER_DEGREE),o=E(e.stRotation,0),n=E(e.perPositionHeight,!1),c=n&&C(e.extrudedHeight),s=E(e.height,0),l=E(e.extrudedHeight,s);if(!c){var g=Math.max(s,l);l=Math.min(s,l),s=g}this._vertexFormat=q.clone(t),this._ellipsoid=S.clone(i),this._granularity=a,this._stRotation=o,this._height=s,this._extrudedHeight=l,this._closeTop=E(e.closeTop,!0),this._closeBottom=E(e.closeBottom,!0),this._extrudeOutering=E(e.extrudeOutering,!0),this._polygonHierarchy=r,this._perPositionHeight=n,this._perPositionHeightExtrude=c,this._shadowVolume=E(e.shadowVolume,!1),this._workerName="createPolygonGeometry",this._offsetAttribute=e.offsetAttribute,this._arcType=E(e.arcType,Z.GEODESIC),this._groundBottomAltitude=E(e.groundBottomAltitude,0),this._groundExtrudedHeight=E(e.groundExtrudedHeight,0),this._rectangle=void 0,this._textureCoordinateRotationPoints=void 0,this._isComputeTexCoord=e.isComputeTexCoord,this._isWall=E(e.isWall,!1),this.packedLength=j.computeHierarchyPackedLength(r)+S.packedLength+q.packedLength+12}B.fromPositions=function(e){e=E(e,E.EMPTY_OBJECT),V.defined("options.positions",e.positions);var r={polygonHierarchy:{positions:e.positions},height:e.height,extrudedHeight:e.extrudedHeight,vertexFormat:e.vertexFormat,stRotation:e.stRotation,ellipsoid:e.ellipsoid,granularity:e.granularity,perPositionHeight:e.perPositionHeight,closeTop:e.closeTop,closeBottom:e.closeBottom,offsetAttribute:e.offsetAttribute,arcType:e.arcType,isComputeTexCoord:e.isComputeTexCoord,isWall:e.isWall};return new B(r)};B.pack=function(e,r,t){return V.typeOf.object("value",e),V.defined("array",r),t=E(t,0),t=j.packPolygonHierarchy(e._polygonHierarchy,r,t),S.pack(e._ellipsoid,r,t),t+=S.packedLength,q.pack(e._vertexFormat,r,t),t+=q.packedLength,r[t++]=e._height,r[t++]=e._extrudedHeight,r[t++]=e._granularity,r[t++]=e._stRotation,r[t++]=e._perPositionHeightExtrude?1:0,r[t++]=e._perPositionHeight?1:0,r[t++]=e._closeTop?1:0,r[t++]=e._closeBottom?1:0,r[t++]=e._shadowVolume?1:0,r[t++]=E(e._offsetAttribute,-1),r[t++]=e._arcType,r[t]=e.packedLength,r};var lr=S.clone(S.UNIT_SPHERE),pr=new q,_r={polygonHierarchy:{}};B.unpack=function(e,r,t){V.defined("array",e),r=E(r,0);var i=j.unpackPolygonHierarchy(e,r);r=i.startingIndex,delete i.startingIndex;var a=S.unpack(e,r,lr);r+=S.packedLength;var o=q.unpack(e,r,pr);r+=q.packedLength;var n=e[r++],c=e[r++],s=e[r++],l=e[r++],g=e[r++]===1,T=e[r++]===1,v=e[r++]===1,P=e[r++]===1,D=e[r++]===1,L=e[r++],p=e[r++],u=e[r];return C(t)||(t=new B(_r)),t._polygonHierarchy=i,t._ellipsoid=S.clone(a,t._ellipsoid),t._vertexFormat=q.clone(o,t._vertexFormat),t._height=n,t._extrudedHeight=c,t._granularity=s,t._stRotation=l,t._perPositionHeightExtrude=g,t._perPositionHeight=T,t._closeTop=v,t._closeBottom=P,t._shadowVolume=D,t._offsetAttribute=L===-1?void 0:L,t._arcType=p,t.packedLength=u,t};B.computeRectangle=function(e,r){V.typeOf.object("options",e),V.typeOf.object("options.polygonHierarchy",e.polygonHierarchy);var t=E(e.granularity,m.RADIANS_PER_DEGREE),i=E(e.arcType,Z.GEODESIC);if(i!==Z.GEODESIC&&i!==Z.RHUMB)throw new Pe("Invalid arcType. Valid options are ArcType.GEODESIC and ArcType.RHUMB.");var a=e.polygonHierarchy,o=E(e.ellipsoid,S.WGS84);return ke(a.positions,o,i,t,r)};B.createGeometry=function(e){var r=e._vertexFormat,t=e._ellipsoid,i=e._granularity,a=e._stRotation,o=e._polygonHierarchy,n=e._perPositionHeight,c=e._closeTop,s=e._closeBottom,l=e._arcType,g=o.positions;if(!(g.length<3)){var T=ae.fromPoints(g,t),v=j.polygonsFromHierarchy(o,T.projectPointsOntoPlane.bind(T),!n,t),P=v.hierarchy,D=v.polygons;if(P.length!==0){g=P[0].outerRing;var L=j.computeBoundingRectangle(T.plane.normal,T.projectPointOntoPlane.bind(T),g,a,$e),p=[],u=e._height,N=e._extrudedHeight,b=e._perPositionHeightExtrude||!m.equalsEpsilon(u,N,0,m.EPSILON2),d={perPositionHeight:n,vertexFormat:r,geometry:void 0,tangentPlane:T,boundingRectangle:L,ellipsoid:t,stRotation:a,bottom:!1,top:!0,wall:!1,extrude:!1,arcType:l,outerPositions:g,isComputeTexCoord:e._isComputeTexCoord},w;if(b)for(d.extrude=!0,d.top=c,d.bottom=s,d.shadowVolume=e._shadowVolume,d.offsetAttribute=e._offsetAttribute,w=0;w<D.length;w++){var A=mr(t,D[w],i,P[w],n,c,s,r,l,e._extrudeOutering,e._isWall),f;c&&s?(f=A.topAndBottom,d.geometry=j.scaleToGeodeticHeightExtruded(f.geometry,u,N,t,n)):c?(f=A.topAndBottom,f.geometry.attributes.position.values=ne.scaleToGeodeticHeight(f.geometry.attributes.position.values,u,t,!n),d.geometry=f.geometry):s&&(f=A.topAndBottom,f.geometry.attributes.position.values=ne.scaleToGeodeticHeight(f.geometry.attributes.position.values,N,t,!0),d.geometry=f.geometry),(c||s)&&(d.wall=!1,f.geometry=Ce(d),p.push(f));var y=A.walls;d.wall=!0;for(var H=0;H<y.length;H++){var U=y[H];d.top=!1,d.bottom=!1,d.geometry=j.scaleToGeodeticHeightExtruded(U.geometry,u,N,t,n),U.geometry=Ce(d),p.push(U)}}else for(w=0;w<D.length;w++){var R=new le({geometry:j.createGeometryFromPositions(t,D[w],i,n,r,l)});if(R.geometry.attributes.position.values=ne.scaleToGeodeticHeight(R.geometry.attributes.position.values,u,t,!n),d.geometry=R.geometry,R.geometry=Ce(d),C(e._offsetAttribute)){var M=R.geometry.attributes.position.values.length,k=new Uint8Array(M/3),_=e._offsetAttribute===ye.NONE?0:1;me(k,_),R.geometry.attributes.applyOffset=new ee({componentDatatype:x.UNSIGNED_BYTE,componentsPerAttribute:1,values:k})}p.push(R)}var I=Ie.combineInstances(p)[0];I.attributes.position.values=new Float64Array(I.attributes.position.values),I.indices=Ee.createTypedArray(I.attributes.position.values.length/3,I.indices);var J=I.attributes,ve=Se.fromVertices(J.position.values);return r.position||delete J.position,new Ne({attributes:J,indices:I.indices,primitiveType:I.primitiveType,boundingSphere:ve,offsetAttribute:e._offsetAttribute})}}};B.createShadowVolume=function(e,r,t){var i=e._granularity,a=e._ellipsoid,o=e._groundBottomAltitude+e._groundExtrudedHeight,n=e._groundBottomAltitude?e._groundBottomAltitude:r(i,a),c=o!==e._groundBottomAltitude?o:t(i,a);return new B({polygonHierarchy:e._polygonHierarchy,ellipsoid:a,stRotation:e._stRotation,granularity:i,perPositionHeight:!1,extrudedHeight:n,height:c,vertexFormat:q.POSITION_ONLY,shadowVolume:!0,arcType:e._arcType})};function gr(e){var r=-e._stRotation;if(r===0)return[0,0,0,1,1,0];var t=e._ellipsoid,i=e._polygonHierarchy.positions,a=e.rectangle;return Ne._textureCoordinateRotationPoints(i,r,t,a)}Object.defineProperties(B.prototype,{rectangle:{get:function(){if(!C(this._rectangle)){var e=this._polygonHierarchy.positions;this._rectangle=ke(e,this._ellipsoid,this._arcType,this._granularity)}return this._rectangle}},textureCoordinateRotationPoints:{get:function(){return C(this._textureCoordinateRotationPoints)||(this._textureCoordinateRotationPoints=gr(this)),this._textureCoordinateRotationPoints}}});var Tr=new F,Pr=new F,dr=new K;function Be(e,r,t,i,a,o){let n=e.longitude,c=n>=0?n:n+m.TWO_PI;a.westOverIdl=Math.min(a.westOverIdl,c),a.eastOverIdl=Math.max(a.eastOverIdl,c),o.west=Math.min(o.west,n),o.east=Math.max(o.east,n);let s=e.getLatitude(t),l=s;if(o.south=Math.min(o.south,s),o.north=Math.max(o.north,s),i!==Z.RHUMB){let v=F.subtract(r.position,e.position,Tr),P=F.dot(r.position,v)/F.dot(v,v);if(P>0&&P<1){let D=F.add(r.position,F.multiplyByScalar(v,-P,v),Pr),L=K.clone(r,dr);L.position=D;let p=L.getLatitude(t);o.south=Math.min(o.south,p),o.north=Math.max(o.north,p),Math.abs(s)>Math.abs(p)&&(l=p)}}let g=r.x*e.y-e.x*r.y,T=Math.sign(g);T!==0&&(T*=F.angleBetween(r.position,e.position)),l>=0&&(a.northAngle+=T),l<=0&&(a.southAngle+=T)}var Ue=new K,wr=new K,z={northAngle:0,southAngle:0,westOverIdl:0,eastOverIdl:0};B.computeRectangleFromPositions=function(e,r,t,i){if(V.defined("positions",e),C(i)||(i=new de),e.length<3)return i;i.west=Number.POSITIVE_INFINITY,i.east=Number.NEGATIVE_INFINITY,i.south=Number.POSITIVE_INFINITY,i.north=Number.NEGATIVE_INFINITY,z.northAngle=0,z.southAngle=0,z.westOverIdl=Number.POSITIVE_INFINITY,z.eastOverIdl=Number.NEGATIVE_INFINITY;let a=e.length,o=K.fromCartesian(e[0],wr);for(let n=1;n<a;n++){let c=K.fromCartesian(e[n],Ue);Be(c,o,r,t,z,i),o=K.clone(c,o)}return Be(K.fromCartesian(e[0],Ue),o,r,t,z,i),i.east-i.west>z.eastOverIdl-z.westOverIdl&&(i.west=z.westOverIdl,i.east=z.eastOverIdl,i.east>m.PI&&(i.east=i.east-m.TWO_PI),i.west>m.PI&&(i.west=i.west-m.TWO_PI)),m.equalsEpsilon(Math.abs(z.northAngle),m.TWO_PI,m.EPSILON10)&&(i.north=m.PI_OVER_TWO,i.east=m.PI,i.west=-m.PI),m.equalsEpsilon(Math.abs(z.southAngle),m.TWO_PI,m.EPSILON10)&&(i.south=-m.PI_OVER_TWO,i.east=m.PI,i.west=-m.PI),i};var Le=B;function Er(e,r){return C(r)&&(e=Le.unpack(e,r)),e._ellipsoid=S.clone(e._ellipsoid),Le.createGeometry(e)}var lt=Er;export{lt as default};
